print(sessionInfo())
cat(paste('Biostrings version:', packageVersion('Biostrings'), '\n'))

args <- commandArgs(TRUE)

taxid_in <- args[[1]]
dna <- Biostrings::readDNAStringSet(args[[2]])

# modify this if you don't want all these ranks (especially if they don't even exist in the input taxonomy annotations)
# I wrote this script with a custom database derived from Silva; mileage may vary for BLCA outputs that used other databases
ranks <- c('Superkingdom', 'Kingdom', 'Subkingdom',
           'Superphylum',  'Phylum',  'Subphylum',
           'Superclass',   'Class',   'Subclass', 'Infraclass',
           'Superorder',   'Order',   'Suborder', 'Infraorder', 'Parvorder',
           'Superfamily',  'Family',  'Subfamily',
                           'Tribe',   'Subtribe',
                           'Genus',   'Subgenus',
                           'Species', 'Subspecies')

## import blca output - produces only two columns; one is the asv name and one is the semicolon-separated taxonomy
taxid_raw <- read.table(taxid_in, sep = '\t')

## input taxonomy table has ASV IDs, but for some reason I want the output to have the actual ASV sequences rather than their IDs
taxid_raw[,1] <- as.character(dna)[taxid_raw[,1]]

## create a list where each element is a taxonomy vector split by semicolon
splittax <- strsplit(taxid_raw[,2], ';')

## collapse list into a square matrix (might be clearer to preallocate a matrix and fill it with a for loop)
taxid_raw <- cbind(taxid_raw[,1],
                   t(simplify2array(sapply(splittax, \(x) {
                     if(length(x) == 1) {
                       # 'Unclassified' sequences are just the single word. In such a case, this pads the vector with NAs at all the lower hierarchical ranks
                       return(c(x, rep(NA, 2 * length(ranks) - 1)))
                     } else {
                       # BLCA output should otherwise all have consistent lengths that allow sapply to simplify the result to a square matrix
                       return(x)
                     }
                   }))))

## create an organized matrix with meaningful column names and the rank names removed from the taxonomies themselves
taxid <- matrix(NA, nrow = nrow(taxid_raw), ncol = length(ranks), dimnames = list(taxid_raw[,1], ranks))
for(i in 1:nrow(taxid)) {
  
  # for each asv, format taxonomy
  for(j in ranks) {
    # for each rank, find all entries that contain the rank name
    col <- grep(j,taxid_raw[i,])
    if(length(col>0)) {
      # keep only the first entry (for instance the rank 'genus' would match both to 'genus' and 'subgenus', so only keep the first)
      # should the grep command just be modified to find exact matches, or did I do it this way for a reason...?
      col <- col[[1]]
      if(as.numeric(taxid_raw[i,col+1]) > 50) {
        # each classification column is followed by a column with the respective confidence score. 
        # if this score is above 50, then remove the rank name from the taxonomic identity and assign it to the appropriate location in the table
        taxid[i,j] <- sub(paste0(j, ':'), '', taxid_raw[i,col])
      } else {
        # if confidence is lower than 50, then ignore this and all more precise ranks (leaving them as NA)
        break
      }
    }
  }
  
  # replace character string NAs generated by BLCA with actual NAs
  taxid[i,taxid[i,]=='NA'] <- NA
  
  # fill in remaining NAs
  for(j in length(ranks):2) {
    if(!is.na(taxid[i,j])) {
      if(grepl(paste0(taxid[i,j-1], '_'), taxid[i,j])) {
        # if it's not already NA, but it should be (the lower taxonomic classification is equivalent to the next higher level), then replace it with NA
        taxid[i,j] <- NA
      } else {
        # if it's not NA but not equivalent to the next higher level, then it's a valid classification, so move on to the next ASV
        break
      }
    }
  }
  
}

write.table(taxid, file=sub('.txt','_clean.txt',taxid_in), sep='\t', quote=F)
